{% extends "layout.html" %}

{% block title %}Path of Ages - Interactive Map{% endblock %}

{% block content %}
<div class="container">
    <div class="map-controls">
        <div class="button-group">
            <button id="map1-btn" class="map-btn active">Political Map</button>
            <button id="map2-btn" class="map-btn">Terrain Map</button>
        </div>
        <div class="session-selector">
            <label for="session-select">Session: </label>
            <select id="session-select">
                {% for session in range(current_session, 0, -1) %}
                    <option value="{{ session }}" {% if loop.first %}selected{% endif %}>Session {{ session }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="slider-container">
            <label for="opacity-slider">Overlay Opacity: </label>
            <input type="range" id="opacity-slider" min="0" max="100" value="0">
            <span id="opacity-value">0%</span>
        </div>
    </div>
    
    <div id="map-viewer" class="map-viewer"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/openseadragon@3.1.0/build/openseadragon/openseadragon.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Get current session from the select element
        const sessionSelect = document.getElementById('session-select');
        const currentSession = parseInt(sessionSelect.value);
        
        // Initialize OpenSeadragon viewer with just the current session maps
        const viewer = OpenSeadragon({
            id: "map-viewer",
            prefixUrl: "https://cdn.jsdelivr.net/npm/openseadragon@3.1.0/build/openseadragon/images/",
            tileSources: [
                {
                    type: 'image',
                    url: `{{ url_for('static', filename='images/maps/') }}PoA_Political_Map_Session_${currentSession}.webp`,
                    buildPyramid: false
                }
            ],
            showNavigationControl: true,
            navigatorPosition: "BOTTOM_RIGHT",
            zoomInButton: "zoom-in",
            zoomOutButton: "zoom-out",
            homeButton: "home",
            fullPageButton: "full-page",
            maxZoomPixelRatio: 2,
            minZoomImageRatio: 0.1,
            visibilityRatio: 0.1,
            constrainDuringPan: false
        });
        
        // Add the terrain map as an overlay
        viewer.addTiledImage({
            tileSource: {
                type: 'image',
                url: "{{ url_for('static', filename='images/maps/PoA_Terrain_Map.webp') }}",
                buildPyramid: false
            },
            opacity: 0,
            index: 1
        });
        
        // Create a cache for preloaded maps
        const mapCache = {
            political: {},
            terrain: { default: "{{ url_for('static', filename='images/maps/PoA_Terrain_Map.webp') }}" }
        };
        
        // Add current session to cache
        mapCache.political[currentSession] = `{{ url_for('static', filename='images/maps/') }}PoA_Political_Map_Session_${currentSession}.webp`;
        
        // Function to preload an image
        function preloadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(url);
                img.onerror = () => reject(url);
                img.src = url;
            });
        }
        
        // Preload maps in background
        function preloadMaps() {
            // Get all session values
            const sessions = Array.from(sessionSelect.options).map(opt => parseInt(opt.value));
            
            // Filter out already cached sessions
            const sessionsToLoad = sessions.filter(session => !mapCache.political[session]);
            
            // Preload in batches of 2 to avoid overwhelming the browser
            const batchSize = 2;
            let currentBatch = 0;
            
            function loadNextBatch() {
                const batch = sessionsToLoad.slice(currentBatch, currentBatch + batchSize);
                if (batch.length === 0) return;
                
                const promises = batch.map(session => {
                    const url = `{{ url_for('static', filename='images/maps/') }}PoA_Political_Map_Session_${session}.webp`;
                    return preloadImage(url).then(() => {
                        mapCache.political[session] = url;
                        console.log(`Preloaded map for session ${session}`);
                    }).catch(() => {
                        console.warn(`Failed to preload map for session ${session}`);
                    });
                });
                
                Promise.all(promises).then(() => {
                    currentBatch += batchSize;
                    if (currentBatch < sessionsToLoad.length) {
                        // Wait a bit before loading next batch
                        setTimeout(loadNextBatch, 1000);
                    }
                });
            }
            
            // Start preloading after a delay to ensure main content loads first
            setTimeout(loadNextBatch, 2000);
        }
        
        // Start preloading maps
        preloadMaps();
        
        // Session selector
        sessionSelect.addEventListener('change', function() {
            const session = this.value;
            const currentMapType = map1Btn.classList.contains('active') ? 'Political' : 'Terrain';
            
            // Remove current maps
            viewer.world.removeAll();
            
            // Add political map for selected session
            viewer.addTiledImage({
                tileSource: {
                    type: 'image',
                    url: mapCache.political[session] || `{{ url_for('static', filename='images/maps/') }}PoA_Political_Map_Session_${session}.webp`,
                    buildPyramid: false
                },
                index: 0,
                opacity: currentMapType === 'Political' ? 1 : 0
            });
            
            // Add terrain map
            viewer.addTiledImage({
                tileSource: {
                    type: 'image',
                    url: mapCache.terrain.default,
                    buildPyramid: false
                },
                index: 1,
                opacity: currentMapType === 'Terrain' ? 1 : 0
            });
            
            // If this map wasn't cached, add it to cache
            if (!mapCache.political[session]) {
                mapCache.political[session] = `{{ url_for('static', filename='images/maps/') }}PoA_Political_Map_Session_${session}.webp`;
            }
        });
        
        // Map switching buttons
        const map1Btn = document.getElementById('map1-btn');
        const map2Btn = document.getElementById('map2-btn');
        
        map1Btn.addEventListener('click', function() {
            viewer.world.getItemAt(0).setOpacity(1);
            viewer.world.getItemAt(1).setOpacity(0);
            document.getElementById('opacity-slider').value = 0;
            document.getElementById('opacity-value').textContent = '0%';
            map1Btn.classList.add('active');
            map2Btn.classList.remove('active');
        });
        
        map2Btn.addEventListener('click', function() {
            viewer.world.getItemAt(0).setOpacity(0);
            viewer.world.getItemAt(1).setOpacity(1);
            document.getElementById('opacity-slider').value = 100;
            document.getElementById('opacity-value').textContent = '100%';
            map2Btn.classList.add('active');
            map1Btn.classList.remove('active');
        });
        
        // Opacity slider
        const opacitySlider = document.getElementById('opacity-slider');
        const opacityValue = document.getElementById('opacity-value');
        
        opacitySlider.addEventListener('input', function() {
            const value = parseInt(this.value);
            opacityValue.textContent = value + '%';
            
            // Set opacity of the overlay
            viewer.world.getItemAt(1).setOpacity(value / 100);
            
            // Update button active states based on slider position
            if (value < 50) {
                map1Btn.classList.add('active');
                map2Btn.classList.remove('active');
            } else {
                map2Btn.classList.add('active');
                map1Btn.classList.remove('active');
            }
        });
    });
</script>
{% endblock %}
